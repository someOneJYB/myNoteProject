网络主要是现在认为的：
- 数据链路层
- 网络层 ip
- 传输层 tcp udp
- 应用层 http


tcp 三次握手：


1、client 向 server 端发送 syn 信号建立连接


2、server 回复 syn + ack 表示收到了建立请求的链接请 client 确认一下


3、client 收到 syn+ack 之后发送 ack 双方建立连接连接


如果在第一步结束后没有收到 sever 的回复，client 会会周期性超时重传 syn，直到收到 server 的ack+syn 确认回复
在第三步如果服务端始终没有收到 client 的回应 ack 就会周期性超时重传 syn+ack
client 发完ACK，单方面认为TCP为 Established状态，而server显然认为TCP为Active状态：


a. 假定此时双方都没有数据发送，client会周期性超时重传，直到收到server的确认，收到之后client的TCP 连接也为 Established状态，双向可以发包。



b. 假定此时client有数据发送，server收到client的 Data + ACK，自然会切换为established 状态，并接受A的Data。


c. 假定server有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到client的确认才可以发送数据。


可以看出在第一次握手之后，对于结果的响应可以超时重连传，在第二次握手之后没收到信息没收到server回复也会超时重连。
TCP的设计者将SYN这个同步标志位SYN设计成占用一个字节的编号（FIN标志位也是），既然是一个字节的数据，按照TCP对有数据的TCP segment 必须确认的原则，所以在这里A必须给B一个确认，以确认A已经接收到B的同步信号。ack收不到不会重新传递，但是会重传 syn。


### 为什么三次握手：


第一次握手：客户端发送网络包，服务端收到了。


这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。


第二次握手：服务端发包，客户端收到了。


这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。


第三次握手：客户端发包，服务端收到了。


这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。


第一次、第二次握手不可以携带数据


### 四次挥手：


客户端：fin server：fin + ack server：fin +ack client：ack 


因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。


##### http 和 https


![5d44c464663b4a4b2b8b78e4bc2522fc](http://localhost:9035/1-1.jpg)


### Charles原理


Charles抓包工具也可以完成https协议的数据内容抓取，其大概原理就是在客户端的视角把自己伪造成服务端、在服务端的视角把自己伪造成客户端。
其中Charles配置抓包https的流程如下：


### pc端Charles下载自己对应的证书；


- 使用客户端安装pc端上Charles的证书，输入网址下载；
- 客户端信任该证书；
- pc端Charles设置443https端口代理；
- 客户端开始调用进行抓包。


### Charles https抓包原理（中间人攻击）


- Charles拦截客户端的请求，伪装成客户端向服务器进行请求；
- 服务器向“客户端”（实际上是Charles）返回服务器的CA证书；
- Charles拦截服务器的响应，获取服务器证书公钥，然后自己制作一张证书，将服务器证书替换后发送给客户端。（这一步，Charles拿到了服务器证书的公钥）
- 客户端接收到“服务器”（实际上是Charles）的证书后，生成一个对称密钥，用Charles的公钥加密，发送给“服务器”（Charles）
- Charles拦截客户端的响应，用自己的私钥解密对称密钥，然后用服务器证书公钥加密，发送给服务器。（这一步，Charles拿到了对称密钥）
- 服务器用自己的私钥解密对称密钥，向“客户端”（Charles）发送响应
- Charles拦截服务器的响应，替换成自己的证书后发送给客户端


### 那为什么有些app无法抓包


- 服务器配置的证书被打包到了客户端程序，客户端校验服务器返回的https证书的时候会先和本地证书做匹配。Charles抓https的包其实就是中间人攻击，对客户端伪装成服务端，对服务端伪装成客户端。用Charles抓包的时候在手机上信任的证书就是Charles的https证书，如果客户端做了类似饿了么的操作，打包了真实服务器的证书，那么证书校验的时候会发现，从服务器返回的证书和本地证书不一致，握手就不会成功，自然抓不到包了。但是打包的就是服务端的公钥。所以就不认 charles 的公钥。
