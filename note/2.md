### 引言
- 既然作用域是用来规范变量查询的，那么就必须了解一下JS中的变量查询方式分类：①左查询(LHS)②右查询(RHS)。他们有着不同的行为，同时也是JavaScript中一些「怪异」现象的源头。



- 左查询(LHS)是指当变量位于赋值操作符的左侧时将进行左查询,引擎将要查找到存储变量的容器本身，以便对变量进行赋值操作。右查询则是指当变量位于赋值操作符右侧时进行的查询操作，但更确切地说是所有「非左侧」查询都属于右查询。一句话说就是左查询发生在赋值时，而右查询发生在引用变量时。



- 他们的区别在于：在非严格模式下，在当前作用域以及沿着作用域链向上查找都找不到目标变量时，右查询(RHS)将会抛出ReferenceError异常，这符合我们的预期，但是左查询在同样的情况下会在全局作用域中自动声明一个同名变量然后返回给查询者。在严格模式下如果找不到变量，两种查询方式都会报ReferenceError异常。




### 一次右查询RHS


```js
console.log(a); //ReferenceError
````

### 一次左查询LHS


```js
a = 1;
console.log(a); // 1——自动创建了全局变量a
```


- 综上也就是我们为什么不使用 var 定义的时候赋值也不会报错因为判断没有就会直接创建一个。
当JavaScript代码执行的时候，会进入不同的执行环境(执行上下文)，这些执行环境会构成了一个执行环境栈(执行上下文栈)（Execution context stack，ECS）
活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object
，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。


- 活动对象是在进入函数执行环境时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。


```js
console.log(a);
var a = "孙悟空";
function a(){ console.log("小钻风"); }
```


相当于


```js
function a(){
    console.log("小钻风");
}
var a;
//上面函数已声明a,相同的变量名声明会被直接忽略
console.log(a);
//输出函数本体
a = "孙悟空";
```


为啥函数提前之后又var a；了怎么不输出undefined，因为这里只是再次声明a，并未修改现有a的值，做个简单测试就可以了：


```js
var a=1;
var a;
console.log(a);
// 1
```


```js
// 隐藏的函数声明 和 变量 a 的声明。
console.log(a)// ?
a();// ?
var a =3;
function a(){
   console.log(10);
}
console.log(a);// ?
a = 6;
a();// ?
```

相当于


```js
function a(){
   console.log(10);
}
var a;
// 结合上面的例子发现 a 现在是函数
console.log(a)// 函数
a();// 函数结果
a = 3
console.log(a);//3
a = 6;
a();// 报错
```


### 函数会首先被提升，然后才是变量。也就是说，同一作用域下提前，函数会在更前面 所以在最前面的是函数声明
